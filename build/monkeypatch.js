// Generated by CoffeeScript 1.7.1
(function() {
  var Format, Leaf, Leaf_isLeafNode, Line, Line_findLeaf, Normalizer, Normalizer_optimizeLine, Normalizer_whitelistStyles, Quill, dom, matches, _;

  Quill = require('quill');

  _ = Quill.require('lodash');

  dom = Quill.require('dom');

  Normalizer = Quill.require('normalizer');

  Line = Quill.require('core/line');

  Leaf = Quill.require('core/leaf');

  Format = Quill.require('core/format');

  if (!Normalizer) {
    throw new Error('BUG: Need a custom version of Quill that exposes normalizer');
  }

  Quill.DEFAULTS.formats.push('math');

  Format.FORMATS['math'] = {
    attribute: 'data-math',
    tag: 'SPAN'
  };

  matches = function(el, selector) {
    var m;
    m = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector;
    if (!m) {
      return false;
    }
    return m.call(el, selector);
  };

  Normalizer_whitelistStyles = Normalizer.whitelistStyles;

  Normalizer.whitelistStyles = function(node) {
    if (matches(node, '[data-math] *')) {
      return;
    }
    return Normalizer_whitelistStyles(node);
  };

  Normalizer_optimizeLine = Normalizer.optimizeLine;

  Normalizer.optimizeLine = function(lineNode) {
    var lineNodeLength, node, nodes, _results;
    lineNode.normalize();
    lineNodeLength = dom(lineNode).length();
    nodes = dom(lineNode).descendants();
    _results = [];
    while (nodes.length > 0) {
      node = nodes.pop();
      if ((node != null ? node.parentNode : void 0) == null) {
        continue;
      }
      if (dom.EMBED_TAGS[node.tagName] != null) {
        continue;
      }
      if (node.tagName === dom.DEFAULT_BREAK_TAG) {
        if (lineNodeLength !== 0) {
          _results.push(dom(node).remove());
        } else {
          _results.push(void 0);
        }
      } else if (dom(node).length() === 0 && !matches(node, '[data-math] *')) {
        nodes.push(node.nextSibling);
        _results.push(dom(node).unwrap());
      } else if ((node.previousSibling != null) && node.tagName === node.previousSibling.tagName) {
        if (_.isEqual(dom(node).attributes(), dom(node.previousSibling).attributes())) {
          nodes.push(node.firstChild);
          _results.push(dom(node.previousSibling).merge(node));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Line_findLeaf = Line.prototype.findLeaf;

  Line.prototype.findLeaf = function(leafNode) {
    var curLeaf, found, leafNodeDom;
    found = Line_findLeaf.apply(this, arguments);
    if (found != null) {
      return found;
    } else {
      leafNodeDom = dom(leafNode);
      curLeaf = this.leaves.first;
      while (curLeaf != null) {
        if (leafNodeDom.isAncestor(curLeaf.node)) {
          return curLeaf;
        }
        curLeaf = curLeaf.next;
      }
    }
  };

  Leaf_isLeafNode = Leaf.isLeafNode;

  Leaf.isLeafNode = function(node, formats) {
    if (matches(node, '[data-math] .katex')) {
      return true;
    }
    return Leaf_isLeafNode.apply(this, arguments);
  };

}).call(this);

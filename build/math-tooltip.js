// Generated by CoffeeScript 1.7.1
(function() {
  var Quill, Toolbar, Tooltip, dom, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Quill = require('quill');

  Toolbar = Quill.modules.toolbar;

  Tooltip = Quill.modules.tooltip;

  _ = Quill.require('lodash');

  dom = Quill.require('dom');

  module.exports = function(katex) {
    var MathTooltip, renderAllMath;
    MathTooltip = (function(_super) {
      __extends(MathTooltip, _super);

      MathTooltip.DEFAULTS = {
        maxLength: 50,
        template: '<span class="title">Formula: </span> <input class="math-input" type="text" spellcheck="false"> <div class="preview"></div> <div class="preview-error"></div> <div class="ql-btn-group"> <button class="cancel">Cancel</button> <button class="update">Update</button> <button class="remove">Remove</button> </div>'
      };

      function MathTooltip(quill, options) {
        this.quill = quill;
        this.options = options;
        Toolbar.formats.TOOLTIP['math'] = 'math';
        this.options = _.defaults(this.options, Tooltip.DEFAULTS);
        MathTooltip.__super__.constructor.call(this, this.quill, this.options);
        dom(this.container).addClass('ql-math-tooltip');
        this.textbox = this.container.querySelector('.math-input');
        this.preview = this.container.querySelector('.preview');
        this.previewError = this.container.querySelector('.preview-error');
        this.updateButton = this.container.querySelector('.update');
        this.removeButton = this.container.querySelector('.remove');
        this.initListeners();
      }

      MathTooltip.prototype.initListeners = function() {
        this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, (function(_this) {
          return function(range) {
            var anchor, formula;
            renderAllMath(_this.quill);
            if (!((range != null) && range.isCollapsed())) {
              return;
            }
            anchor = _this._findAnchor(range);
            if (anchor) {
              formula = dom(anchor).attributes()['data-math'];
              _this.setMode(formula, true);
              _this._currentInitialFormula = formula;
              _this._currentMathEl = anchor;
              return _this.show(anchor);
            } else {
              _this.range = null;
              _this.range = null;
              return _this.hide();
            }
          };
        })(this));
        dom(this.updateButton).on('click', _.bind(this.saveMath, this));
        dom(this.removeButton).on('click', _.bind(this.removeMath, this));
        dom(this.container.querySelector('.cancel')).on('click', _.bind(this.hideOrRemoveMath, this));
        this.range = null;
        this.initTextbox(this.textbox, this.saveMath, this.hide);
        this._updateMathPreview();
        this.quill.onModuleLoad('toolbar', (function(_this) {
          return function(toolbar) {
            return toolbar.initFormat('math', _.bind(_this._onToolbar, _this));
          };
        })(this));
        dom(this.textbox).on('keyup', _.bind(this._updateMathPreview, this));
        return renderAllMath(this.quill);
      };

      MathTooltip.prototype._updateMathPreview = function() {
        var e, formula;
        formula = this.textbox.value;
        if (formula !== this._currentInitialFormula) {
          try {
            katex.render(formula, this.preview);
            dom(this.updateButton).removeClass('disabled');
            return this.previewError.innerHTML = '';
          } catch (_error) {
            e = _error;
            dom(this.updateButton).addClass('disabled');
            this.preview.innerHTML = '';
            return this.previewError.innerHTML = "Parse Problem: " + e.message;
          }
        } else {
          dom(this.updateButton).addClass('disabled');
          this.preview.innerHTML = '';
          return this.previewError.innerHTML = '';
        }
      };

      MathTooltip.prototype.renderMath = function(node) {
        var e, formula;
        formula = dom(node).attributes()['data-math'];
        try {
          return katex.render(formula, node);
        } catch (_error) {
          e = _error;
          return node.innerHTML = e.message;
        }
      };

      MathTooltip.prototype.show = function() {
        this.quill.editor.doc.root.classList.add('ql-has-active-popup');
        this._updateMathPreview();
        return MathTooltip.__super__.show.apply(this, arguments);
      };

      MathTooltip.prototype.hide = function() {
        this.range = null;
        this._currentInitialFormula = null;
        MathTooltip.__super__.hide.apply(this, arguments);
        return this.quill.editor.doc.root.classList.remove('ql-has-active-popup');
      };

      MathTooltip.prototype.hideOrRemoveMath = function() {
        var node;
        node = this._findAnchor(this.range);
        if (node && dom(node).attributes()['data-math'] !== 'true') {
          return this.hide.apply(this, arguments);
        } else {
          this.removeMath.apply(this, arguments);
          return this.hide.apply(this, arguments);
        }
      };

      MathTooltip.prototype.saveMath = function() {
        var anchor, e, formula, math, url, _i, _len, _ref;
        url = this.textbox.value;
        if (this.range != null) {
          if (this.range.isCollapsed()) {
            anchor = this._findAnchor(this.range);
            if (anchor != null) {
              dom(anchor).attributes({
                'data-math': url
              });
            }
            this.renderMath(anchor);
          } else {
            this.quill.formatText(this.range, 'math', url, 'user');
            _ref = this.quill.editor.root.querySelectorAll('[data-math]');
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              math = _ref[_i];
              formula = dom(math).attributes()['data-math'];
              try {
                katex.render(formula, math);
              } catch (_error) {
                e = _error;
                console.log('Error: Invalid math');
              }
            }
          }
        }
        this.setMode(url, false);
        return this.hide();
      };

      MathTooltip.prototype.removeMath = function() {
        var addedNodes, formula, node, _i, _len, _results;
        node = this._findAnchor(this.range);
        if (node) {
          formula = dom(node).attributes()['data-math'];
          node.removeAttribute('data-math');
          node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
          node.removeClass('loaded');
          if (formula !== 'true') {
            return node.text(formula);
          }
        } else {
          addedNodes = this.quill.editor.doc.root.querySelectorAll('[data-math="true"]');
          addedNodes = __slice.call(addedNodes);
          _results = [];
          for (_i = 0, _len = addedNodes.length; _i < _len; _i++) {
            node = addedNodes[_i];
            node.removeAttribute('data-math');
            node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
            _results.push(node.removeClass('loaded'));
          }
          return _results;
        }
      };

      MathTooltip.prototype.setMode = function(url, edit) {
        if (edit == null) {
          edit = false;
        }
        if (edit) {
          this.textbox.value = url;
          _.defer((function(_this) {
            return function() {
              _this.textbox.focus();
              return _this.textbox.setSelectionRange(url.length, url.length);
            };
          })(this));
        } else {
          this.textbox.value = url;
        }
        return dom(this.container).toggleClass('editing', edit);
      };

      MathTooltip.prototype._findAnchor = function(range) {
        var leaf, node, offset, _ref;
        _ref = this.quill.editor.doc.findLeafAt(range.start, true), leaf = _ref[0], offset = _ref[1];
        if (leaf != null) {
          node = leaf.node;
        }
        while (node != null) {
          if (dom(node).attributes()['data-math'] != null) {
            return node;
          }
          node = node.parentNode;
        }
        return null;
      };

      MathTooltip.prototype._onToolbar = function(range, value) {
        var nativeRange;
        if (!(range && !range.isCollapsed())) {
          return;
        }
        if (value) {
          this.setMode(this._suggestURL(range), true);
          nativeRange = this.quill.editor.selection._getNativeRange();
          return this.show(nativeRange);
        }
      };

      MathTooltip.prototype._suggestURL = function(range) {
        var text;
        text = this.quill.getText(range);
        return text;
      };

      return MathTooltip;

    })(Tooltip);
    renderAllMath = function(quill) {
      var e, formula, math, _i, _len, _ref, _results;
      _ref = quill.editor.root.querySelectorAll('[data-math]:not(.loaded)');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        math = _ref[_i];
        formula = dom(math).attributes()['data-math'];
        if (formula === 'true') {
          continue;
        }
        try {
          katex.render(formula, math);
          _results.push(math.classList.add('loaded'));
        } catch (_error) {
          e = _error;
          _results.push(console.log('Error: Invalid math'));
        }
      }
      return _results;
    };
    return MathTooltip;
  };

}).call(this);
